时间 ：2021年3月3日
地点：创客大厦
公链开发：
① 先构建一个区块 --->block
    a、区块的定义
    b、创世区块和新区块生成的功能封装
    c、计算区块哈希值计算
    d、寻找符合条件的Nonce值
            共识机制：多节点解决分歧的规则、方法
            解决方法：PoW 、PoS 、DPoS 、PBft、PuA...

            PoW算法：给定一个系统目标值，寻找随机数、计算区块hash，
                        将hash与系统目标值进行比较

② 生成多个区块
③ 把多个区块链接起来 ---> blockchain
    a、管理员手动管理区块
    b、封装一个具有区块管理功能的模块，它应该有自动化生产、追加、查询、获取区块的能力

④ 把区块链保存起来
         （序列化）
    a、把已有的内存中的多个区块持久化存储起来 --->json、xml、gob（[]byte）
    b、[]byte -->读写（IO）-->持久化媒介：云、文件、数据库
            文件： Write、Read （IO.Writer 、IO.Reader ）
                a、原生API （Application Programming Interface）：os.OpenFile /  os.Open  Write写数据 Reader读数据
                优点：最原始、最底层的技术支持
                缺点：易用性低

                b、第三方SDK（Software Development Kit）：boltDB
                优点：效率高、封装性好
                缺点：仅提供某些特定方向的技术支持
                用法： 先搞明白第三方库的功能和使用步骤：
                bolt.Open -> db.View 、db.Updata ->tx.CreateBucket -->put、get
                       将第三方库集成到已有的项目中
                            1、在项目中新建db模块、封装持久化存储功能
                            a、将内存中的数据存储到文件中
                            b、从文件中读取数据到内存
                 优点：思路简单，容易想到
                 弊端：要保证文件中的数据与内存中的切片数据一致，增加了维护成本，避免数据混乱
                        2、分析：区块中的数据最终目的地是文件，即内存中的Block[]数据是一个


⑤ 多个节点进行数据同步

2021年3月10日14:59:16
引入迭代器 BlockChain中添加IteratorBlockHash属性
    ① IteratorBlockHash初始值为lastBlockHash
迭代器(iterator):一种检查容器内元素并遍历元素的数据类型。
又称游标cursor，是一种设计模式，它是一个对象，用可以遍历选择序列中的对象。
通过它，开发者可以不需要了解该序列的底层结构

2021年3月10日16:11:44
 src ————> build ————>run
    XianFengChain04.exe -————>AddNewBlock(用户输入的数据)

动态交互：机器与人交互：程序将相关新输出给用户
         人与机器交互：用户动态指定一些程序执行的数据，程序能够接收并解析，按照用户的指令进行执行。
 golang命令行参数：
        实例：git commit -m "xxxx"
          思路: go run main.go createBlock <data>
          方案一 ： os.Args : 一个切片，该切片至少有一个元素，存放程序的路径。
          方案二 ： flag.Args: flag.StringVar()/flag.String / flag.Int / flag.IntVar
                       flag.NewFlagSet()
                    flag.Parse()

2021年3月10日17:07:59
 类比样例 go
        bug         start a bug report
        build       compile packages and dependencies
        version     print Go version
        vet         report likely mistakes in packages
        统计已实现的功能：
        1、generategensis 生成创世区块 -gensis 创世区块中的数据
        2、generateblock  生成新区块  -data  新区块中的数据
        3、getlastblock   获取最新区块
        4、getallblocks   获取所有区块
        go run main.go generategensis -
2021年3月11日09:38:46
继承命令行参数解析功能：
    1、新建一个模块client
    2、在client模块中新建各个指令功能函数

2021年3月12日10:30:28
    UTXO：未花费的交易输出

    交易：转账，比特币在两个或多个地址的一次流转
    交易：交易输入，交易输出
                一笔交易可以由一个或多个交易输入，和一个或多个交易输出组成
            交易输入：本质上是对某笔交易的某个交易输出的一个引用
            交易输出：通过一个数据结构，将一定数量的比特币通过锁定脚本锁定在该结构上，等待解锁脚本解锁。


2021年3月16日09:03:09
转账是需要花费比特币的，比特币哪里来，它又是怎么流通的呢？

比特币是怎么来的？由系统负责将一定数量的比特币发放给比特币生成区块的生产者
 系统如何区分不同的用户呢（如何识别矿工呢？） 比特币地址

 比特币地址：是一种标识符，简单的将地址与私钥的所有者进行代替。

 系统发放奖励的交易：coinbase交易
 特点：只有输出，没有输入，系统发起，
 要求：用户必须要告知系统 矿工的地址


 go run main.go generategenesis -address 比特币地址

 构建创世区块：
 1、解析到矿工地址
 2、利用定义的交易相关结构体，构建一个coinbase transaction
 3、将coinbase交易传入CreateGenesis方法参数中
 4、CreateGenesis将生成的区块保存到bolt.DB文件当中


 构建普通的交易：
 举例： A ---> 20 块钱 现金系统
 ① 一张正好:    1 张 20
 ② 多张正好:    2张10元,4张5元,20张1元,1张10元和2张5元
 ③一张找零,多张找零 : 1张50找30,一张100找80

 比特币网络中区别:交易的输出可以是任意的面额

 比特币的交易: A -- > B 10 BTC

    交易的输入              ：             交易的输出
 1、 一个交易输入                          一个交易输出，不用找零
 2、多个交易输入                           一个交易输出，不用找零
 3、一个交易输入                           两个交易输出，需要找零
 4、多个交易输入                           两个交易输出，需要找零

 反推：交易输入 -->  本质上是对某笔交易的某个输出的引用
    a、定位哪笔交易？
    b、定位引用哪个输出？
    如何定位交易：遍历所有的交易，符合条件的就记录下来，
    交易在区块中，想要遍历交易，就要遍历区块，区块在boltDb操作的文件中，从哪开始遍历区块？
    lastblock往前遍历


    反推：交易输出
    如果单向 的 A--- 》B的一笔转账，最多产生两个交易输出，
    output0:转账给接收者的交易输出
    {
        value:转账数量
        scriptPub: B的地址
    }
    如果需要找零，才会有output1，找给A的输出
    output1{
        value:A付的钱 -- 转账的数量，
        scriptPub：A的地址
    }
2021年3月16日10:29:26
构建新交易需要传的参数：
创世区块的coinbase交易 ： -address 矿工地址

普通交易： A --> B
参数：  from
        to
        value

从后往前遍历一次--> inputs 和outPuts都看，
inputs中找到跟   from 有关的记录，表示已花费的输出
outputs中找到跟 from 有关的记录下来，表示davie得到的
遍历完成后，进行outputs的筛选，筛选出所有可用的output



2021年3月17日14:16:30
1、如何寻找某个账户的可花费的钱（UTXO）
txo：TxOutput 交易的输出
UTXO：所有TxOutput的一个子集

①找到跟该账户有关的所有的收入记录
②找到跟该账户有关的所有花费记录
③从所有的收入记录中把已花费的记录剔除
④剩下的收入就是未花费的收入（UTXO）

2、如何把可花费的收入找到？（编程思维）
① 从最后一个区块开始，遍历每一个区块（可以使用 迭代器）
② 遍历每一个区块中的交易
③ a、遍历每一笔交易的交易输入，找到跟 from 相关的 input，记录下来（UTXO解构体定义   区块的位置，交易的id，交易输入的下标，交易输入的金额），
  b、遍历每一笔交易的交易输出，找到跟 from 相关的 output，记录下来。（区块的位置，交易的id，交易输入的下标，交易输入的金额），
④将第三步中a、b两部的拿到的切片进行比较，把已经花费的output剔除掉（或者把未消费的output提出来）。



2021年3月18日11:15:11
比特币系统中：一个区块中可以存放多笔交易 ：[]Transaction
真正实现的 ：一个交易就占一个区块
go run main.go sendtransaciton
    -from   "[ \"yugu\",\"sansui\" ]"
    -to     "[ \"shipeng\",\"liuchao\" ]"
    -amount [10,20]

2021年3月23日09:22:42
特殊的多对多转账：
①一对多转账
    yugu  -->sansui
②多对一转账

2021年3月24日14:12:26
地址生成功能
地址的用途:
① coinbase交易:指定矿工的地址
②普通交易:from和to用于指定发起者和接收者的地址
注意:地址的有效性,地址合法性检查

交易的签名和验签
密码学:ecdsa
    签名
        原始交易+ 私钥
        1.对交易进行hash 得到hash摘要
           2.使用私钥对hash进行签名,得到签名信息

    验签
    公钥 +原始交易信息 + 签名信息
    1.对原始交易信息进行hash计算,得到hash摘要
    2.调用verify函数,传入公钥,hash,还有签名
    3.判断verify函数的返回值,

    2021年3月24日15:07:48
    提供功能:把地址和所对应私钥公钥密钥对给合理的管理起来
    一.使用某笔钱,可以使用私钥进行签名
    二....
    一个完整的比特币客户端: 区块链,矿工,网络路由,钱包

    钱包:管理私钥公钥和地址
        该模块应具有以下几个功能:
                生成密钥对,生成地址,检验地址的合法性




2021年3月24日16:46:25


gob编码 : ① gob编码结构体,结构体包含若干字段,比如 int .string. bool等
          ②gob编码结构体 ,其中包含接口类型. Curve


2021年3月25日10:23:02
钱包模块
    查询所有地址
    导出指定地址的私钥

  签名:  转账交易需要签名

  addr1 的 私钥 对交易进行 签名
            output : 把钱锁在add2

    ScriptSig:解锁脚本
                     <sig> <pubK>
    ScriptPubK:锁定脚本
           DUP HASH160 <PubKHash> EQUALVERIFY CHECKSIG
       操作指令 :  DUP HASH160  EQUALVERIFY CHECKSIG
       数据 :  <sig> <pubK> <PubKHash>
       指令栈 : 压栈 和 弹栈
       指令 : 3 2 ADD 5 EQUAL

公钥hash:
    公钥hash --> 推导计算 --> 地址

    已有地址 --> 反向推导 --> 公钥hash
    addr - >base58解码 --> 去除校验和

第0个地址:       1Bfz1ZYmvuxcA9sSj6R6v6zcFAMdVFe3c3
第1个地址:       1b4XDRdX4nxcotsQ2yMfbzjJ4vY2qhyyS

go run main.go generategenesis -address 1Bfz1ZYmvuxcA9sSj6R6v6zcFAMdVFe3c3
恭喜！生成了一笔COINBASE交易，奖励已到账。

go run main.go getbalance -address 1Bfz1ZYmvuxcA9sSj6R6v6zcFAMdVFe3c3
地址1Bfz1ZYmvuxcA9sSj6R6v6zcFAMdVFe3c3的余额是：50.000000

go run main.go getbalance -address 1b4XDRdX4nxcotsQ2yMfbzjJ4vY2qhyyS
地址1Bfz1ZYmvuxcA9sSj6R6v6zcFAMdVFe3c3的余额是：0.000000

go run main.go sendtransaction -from [\"1Bfz1ZYmvuxcA9sSj6R6v6zcFAMdVFe3c3\",\"1b4XDRdX4nxcotsQ2yMfbzjJ4vY2qhyyS\"] -to [\"1b4XDRdX4nxcotsQ2yMfbzjJ4vY2qhyyS\",\"1Bfz1ZYmvuxcA9sSj6R6v6zcFAMdVFe3c3\"] -amount [30,5]



go run main.go sendtransaction -from [\"13mLgGrTHNBAMtGoq5ke1JUPq4ykUfRygR\"] -to [\"1PW5pnpJa7he33WEsmRe2uBS7KmwNXDZeA\"] -amount [30]



2021年3月30日08:55:09
1.交易签名: 使用私钥对交易进行签名 :
    a.找到与当前交易有关的 UTXO
    b.获取到每一个UTXO中的公钥哈希(pubHash)
    c.对交易进行拷贝复制,在复制的交易对象中遍历每一个交易输入
    d.将每一个交易输入中的 原始公钥(pubKey)字段设置为对应所引用的UTXO的pubkhash
    e.计算改造后的交易的hash
    f.使用私钥对hash值进行签名
    e.将pubk字段清空
    f.将签名结果数据赋值给原始交易对象对应交易输入的Sign字段
2.为什么一定要拷贝一份交易副本?
    原因:签名时要对每一个交易输入中的PubK字段进行值的修改,
    以期让每一个交易输入与之所引用的UTXO产生关联.
    但原始交易数据中的PubK字段需要保留下来,所以我们创建一个副本.
3.在区块链中交易的流程:
    a.创建原始交易
    b.对交易进行签名
    c.将签名后的交易通过P2P网络进行广播给其他节点

    其他节点:
    a.接收来自其他节点的广播交易数据
    b.对交易进行签名验证.
    c.如果签名验证通过,则将交易放入交易池(txPool)中
    d.从交易池中取出一定数量的交易进行打包
    e.构造新区块,工作量证明算法 寻找Nonce值,
    f.如果顺利找到nonce,则将区块持久化存储起来,并广播给其他节点

4.一人分饰两角 :当前只有一个节点,自己发自己接

5.签名验证:
	// 签名 : 私钥 原始数据-->hash计算 -->hash值
	// 验签 : 公钥 签名结果 原始数据 --> hash值
	a. 原始数据 --> hash函数 --> hash值

	b. 调用ecdsa.Verify函数 ,传入 公钥 pub 签名r,签名s, 原始数据hash值

	c.接收返回结果值


	签名后交易对象的Sig字段修改,与原数据签名时的值已经不一致了
	验签 ? 需要把修改后的字段gai



2021年4月2日09:02:57:

bug : gob -> []byte -->sha256 --> TxHash
已修复 --> transaction结构体中新增一个变量 timeStamp
	防止coinbase交易 txHash一致


2021年4月6日08:41:54

1.UTXOSet概念:
    比特币只会在比特币网络通过交易转账的方式中流转,而不会消失.

    交易输出会散落某个区块的某个交易中,
    如果要使用UTXO时,由于不知道输出具体在哪个区块的哪个交易中
    我们需要把所有的交易记录全部遍历一遍.
     效率低,资源浪费(区块会越来越多,交易也会越来越多,越到后面越浪费算力)

优化思路: 在每一次比特币网络发生交易时,都将产生的UTXOs单独存放在一个地方(UTXOSet)
            要用到的时候只要直接去UTXOSet找就好了
     map[address] []UTXO

     编码实现 : 数据结构
     type UTXOSet struct{
        UTXOs map[string] []byte
     }
     增 删 查


    集成:
    QueryUTXOsByAddr    : 发送交易前查询
    AddUTXOsWithAddress : 发送交易
    DeleteUTXOsWithAddr

